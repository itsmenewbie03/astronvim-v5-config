local M = {}

local config = {
  binary_path = "slack-status", -- Go binary in PATH
  default_status = "Working in Neovim",
  mappings = {}, -- filetype → emoji
  fallbacks = {}, -- activity type → emoji
}

-- Load .env file for TOKEN/COOKIES
local function load_env_file(path)
  local f = io.open(path, "r")
  if not f then return end
  for line in f:lines() do
    local key, val = line:match "^([%w_]+)=(.+)$"
    if key and val then
      val = val:gsub("^%s*(.-)%s*$", "%1") -- trim spaces
      vim.fn.setenv(key, val)
    end
  end
  f:close()
end

load_env_file(vim.fn.fnamemodify("~/.config/slack-status/slack-status.env", ":p"))

-- Run Go binary asynchronously
local function set_slack_status(text, emoji)
  if vim.fn.executable(config.binary_path) == 0 then
    vim.notify("Slack status binary not found: " .. config.binary_path, vim.log.levels.ERROR)
    return
  end

  -- Resolve full path to the env file and its directory
  local env_file = vim.fn.fnamemodify("~/.config/slack-status/slack-status.env", ":p")
  local env_dir = vim.fn.fnamemodify(env_file, ":h")
  local log_file = env_dir .. "/slack-status-error.log"

  local cmd = { config.binary_path, "-s", text, "-e", emoji }
  vim.fn.jobstart(cmd, {
    detach = true,
    on_stderr = function(_, data)
      if data and #data > 0 then
        local f = io.open(log_file, "a")
        if f then
          f:write(os.date "[%Y-%m-%d %H:%M:%S] " .. table.concat(data, "\n") .. "\n")
          f:close()
        end
      end
    end,
  })
end

-- Decide emoji based on filetype/context
local function get_emoji()
  local ft = vim.bo.filetype
  if ft and config.mappings[ft] then return config.mappings[ft] end

  -- Prompt contexts
  if vim.bo.buftype == "prompt" or ft == "TelescopePrompt" then return config.fallbacks.prompt or ":speech_balloon:" end

  -- File explorer contexts
  if ft == "neo-tree" or ft == "netrw" then return config.fallbacks.explorer or ":file_folder:" end

  return config.fallbacks.editing or ":keyboard:"
end

-- Determine status text
local function get_status_text()
  local ft = vim.bo.filetype
  local bufname = vim.fn.bufname "%"
  local filename = vim.fn.expand "%:t"

  if filename == "" or bufname == "" or bufname:match "^%[No Name%]$" then
    if vim.bo.buftype == "prompt" or ft == "TelescopePrompt" then
      return "Searching..."
    elseif ft == "neo-tree" or ft == "netrw" then
      return "Browsing files"
    else
      return config.default_status
    end
  end

  return string.format("Editing %s (%s)", filename, ft)
end

-- Public: update Slack status based on context
function M.update_status()
  local emoji = get_emoji()
  local status_text = get_status_text()
  set_slack_status(status_text, emoji)
end

-- Setup & autocmd bindings
function M.setup(opts)
  config = vim.tbl_deep_extend("force", config, opts or {})

  -- Update when switching buffers/windows
  vim.api.nvim_create_autocmd({ "BufEnter", "BufWinEnter", "WinEnter" }, {
    callback = function() M.update_status() end,
  })

  -- Telescope or prompt entry
  vim.api.nvim_create_autocmd("CmdlineEnter", {
    callback = function() set_slack_status("Prompting...", config.fallbacks.prompt or ":speech_balloon:") end,
  })

  -- On exit
  vim.api.nvim_create_autocmd("VimLeavePre", {
    callback = function() set_slack_status("Offline", config.fallbacks.idle or ":coffee:") end,
  })
end

return M
